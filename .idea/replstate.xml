<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1430629114696">{:repl-history {:ide [], :local [&quot;(f2 4)&quot; &quot;(map f2 [1 2 3])&quot; &quot;(defn merge [a b]\n  (cond\n    (empty? a) b\n    (empty? b) a\n    (&lt; (first a) (first b)) (cons (first a) (merge (rest a) b))\n    :else                   (cons (first b) (merge a (rest b)))\n    )\n  (defn f2 [n] (* 2 n))\n  (defn f3 [n] (* 3 n))\n  (defn f5 [n] (* 5 n))\n\n  (defn h [] ( cons 1 ( merge (map f2 h) (map f3 h) (map f5 h) ) ))&quot; &quot;(defn merge [a b]\n  (cond\n    (empty? a) b\n    (empty? b) a\n    (&lt; (first a) (first b)) (cons (first a) (merge (rest a) b))\n    :else (cons (first b) (merge a (rest b)))\n    )\n  )\n  (defn f2 [n] (* 2 n))\n  (defn f3 [n] (* 3 n))\n  (defn f5 [n] (* 5 n))\n\n  (defn h [] ( cons 1 ( merge (map f2 h) (map f3 h) (map f5 h) ) ))&quot; &quot;(nth [1 2 3 4 5] 0)&quot; &quot;(nth [1 2 3 4 5] 1)&quot; &quot;(nth h 0)&quot; &quot;(h)&quot; &quot;(take 5 [1 2 3 4 5 6 7])&quot; &quot;(def h ( cons 1 ( merge (merge (map f2 h) (map f3 h)) (map f5 h) ) ))&quot; &quot;(defn t [] ( cons 1 (map f5 h)))&quot; &quot;(take 5 t)&quot; &quot;(merge [1 2 4] [1 3 5])&quot; &quot;(merge (map f2 [1 2 4]) (map f5 [1 3 5]))&quot; &quot;(defn h [] ( cons 1 ( merge (merge (map f2 h) (map f3 h)) (map f5 h) ) ))&quot; &quot;(defn h [] ( concat [1] ( merge (merge (map f2 h) (map f3 h)) (map f5 h) ) ))&quot; &quot;(defn positive-numbers\n  ([] (positive-numbers 1))\n  ([n] (cons n (lazy-seq (positive-numbers (inc n))))))&quot; &quot;(take 5 positive-numbers)&quot; &quot;(take 5 (positive-numbers))&quot; &quot;(defn h [] ( cons 1 (lazy-seq ( merge (merge (map f2 h) (map f3 h)) (map f5 h) )) ))&quot; &quot;(defn h\n  ([] (h 1))\n  ([n] (cons n (lazy-seq (h (merge (merge (map f2 h) (map f3 h)) (map f5 h)))))))&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) b\n    (empty? b) a\n    (&lt; (first a) (first b)) (cons (first a) (mrg (rest a) b))\n    :else (cons (first b) (mrg a (rest b)))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))&quot; &quot;(defn h [] ( cons 1 (lazy-seq ( mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))&quot; &quot;(def h ( concat [1] (lazy-seq ( mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))&quot; &quot;(def h ( cons 1 (lazy-seq (map f2 h)) ) )&quot; &quot;(def h ( cons 1 (lazy-seq (map inc h)) ) )&quot; &quot;(take 5 (h))&quot; &quot;(def h ( cons 1 (lazy-seq ( mrg (map f2 h) (map f3 h) (map f5 h) )) ))&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (lazy-seq (cons (first a) (mrg (rest a) b)))\n    :else (lazy-seq (cons (first b) (mrg a (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))&quot; &quot;(def h ( cons 1 (lazy-seq ( mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))&quot; &quot;(def h ( cons 1 (lazy-seq ( mrg (lazy-seq (mrg (map f2 h) (map f3 h))) (map f5 h) )) ))&quot; &quot;(def h ( cons 1 (lazy-seq (mrg (map f2 h) (map f5 h) )) ))&quot; &quot;(take 5 h)&quot; &quot;(map f2 [1 2 3 4 5])&quot; &quot;(def h ( cons 1 (lazy-seq (mrg (lazy-seq (map f2 h)) (lazy-seq (map f5 h)) )) ))&quot; &quot;(def h ( cons 1 (lazy-seq (mrg (lazy-seq (map f2 h)) (lazy-seq (map f3 h)) )) ))&quot; &quot;(def h ( cons 1 (lazy-seq (mrg (map f2 h) (map f3 h) )) ))&quot; &quot;(def h ( cons 1 (mrg (map f2 h) (map f3 h) ) ))&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (lazy-seq (cons (first a) (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (lazy-seq (cons (first b) (mrg a (rest b))))\n    :else (lazy-seq (cons (first b) (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))&quot; &quot;(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))&quot; &quot;(nth h 10)&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (lazy-seq (cons (first a) (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (lazy-seq (cons (first b) (mrg a (rest b))))\n    :else (lazy-seq (cons (first b) (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))\n\n(defn hamming [n] (nth h n))&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (lazy-seq (cons (first a) (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (lazy-seq (cons (first b) (mrg a (rest b))))\n    :else (lazy-seq (cons (first b) (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))\n\n(defn hamming [n] (nth h (- n 1)))&quot; &quot;(hamming 0)&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) b\n    (empty? b) a\n    (&lt; (first a) (first b)) (cons (first a) (mrg (rest a) b))\n    (&gt; (first a) (first b)) (cons (first b) (mrg a (rest b)))\n    :else cons (first b) (mrg (rest a) (rest b)))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))&quot; &quot;(def h ( cons 1 (lazy-seq (mrg (lazy-seq (mrg (map f2 h) (map f3 h))) (map f5 h) )) ))&quot; &quot;(hamming 55)&quot; &quot;(hamming 1)&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (lazy-seq (cons (first a) (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (lazy-seq (cons (first b) (mrg a (rest b))))\n    :else (lazy-seq (cons (first b) (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))\n\n(defn hamming [n] (nth h (- n 1)) )\n&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (lazy-seq (cons (first a) (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (lazy-seq (cons (first b) (mrg a (rest b))))\n    :else (lazy-seq (cons (first b) (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h (- n 1)) )\n&quot; &quot;(hamming 15)&quot; &quot;(take h 15)&quot; &quot;(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))\n&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (lazy-seq (cons (first a) (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (lazy-seq (cons (first b) (mrg a (rest b))))\n    :else (lazy-seq (cons (first b) (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) (lazy-seq b)\n    (empty? b) (lazy-seq a)\n    (&lt; (first a) (first b)) (cons (first a) (lazy-seq (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (cons (first b) (lazy-seq (mrg a (rest b))))\n    :else (cons (first b) (lazy-seq (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(take 2 h)&quot; &quot;(take 20 h)&quot; &quot;(take 200 h)&quot; &quot;(take 500 h)&quot; &quot;(defn mrg [a b]\n  (cond\n    (empty? a) b\n    (empty? b) a\n    (&lt; (first a) (first b)) (cons (first a) (lazy-seq (mrg (rest a) b)))\n    (&gt; (first a) (first b)) (cons (first b) (lazy-seq (mrg a (rest b))))\n    :else (cons (first b) (lazy-seq (mrg (rest a) (rest b))))\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) ) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(defn mrg [a b]\n  (lazy-seq\n    (cond\n      (empty? a) b\n      (empty? b) a\n      (&lt; (first a) (first b)) (cons (first a) (mrg (rest a) b))\n      (&gt; (first a) (first b)) (cons (first b) (mrg a (rest b)))\n      :else (cons (first b) (mrg (rest a) (rest b)))\n      )\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(take 10 h)&quot; &quot;(defn mrg [a b]\n  let [a0 (first a) b0 (first b)]\n  (lazy-seq\n    (cond\n      (empty? a) b\n      (empty? b) a\n      (&lt; a0 b0) (cons a0 (mrg (rest a) b))\n      (&gt; a0 b0) (cons b0 (mrg a (rest b)))\n      :else (cons a0 (mrg (rest a) (rest b)))\n      )\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(defn mrg [a b]\n  (let [a0 (first a) b0 (first b)])\n  (lazy-seq\n    (cond\n      (empty? a) b\n      (empty? b) a\n      (&lt; a0 b0) (cons a0 (mrg (rest a) b))\n      (&gt; a0 b0) (cons b0 (mrg a (rest b)))\n      :else (cons a0 (mrg (rest a) (rest b)))\n      )\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(defn mrg [a b]\n  (lazy-seq\n    (let [a0 (first a) b0 (first b)])\n    (cond\n      (empty? a) b\n      (empty? b) a\n      (&lt; a0 b0) (cons a0 (mrg (rest a) b))\n      (&gt; a0 b0) (cons b0 (mrg a (rest b)))\n      :else (cons a0 (mrg (rest a) (rest b)))\n      )\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(defn mrg [a b]\n  (let [a0 (first a) b0 (first b)]\n    (lazy-seq\n      (cond\n        (empty? a) b\n        (empty? b) a\n        (&lt; a0 b0) (cons a0 (mrg (rest a) b))\n        (&gt; a0 b0) (cons b0 (mrg a (rest b)))\n        :else (cons a0 (mrg (rest a) (rest b)))\n        )\n      )\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h (- n 1)) )&quot; &quot;(take 50 h)&quot; &quot;(defn mrg [a b]\n  (let [a0 (first a) b0 (first b)]\n    (lazy-seq\n      (cond\n        (empty? a) b\n        (empty? b) a\n        (&lt; a0 b0) (cons a0 (mrg (rest a) b))\n        (&gt; a0 b0) (cons b0 (mrg a (rest b)))\n        :else (cons a0 (mrg (rest a) (rest b)))\n        )\n      )\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h n) )&quot; &quot;(hamming 10)&quot; &quot;(take 100 h)&quot; &quot;(defn mrg [a b]\n    (lazy-seq\n      (let [a0 (first a) b0 (first b)]\n      (cond\n        (empty? a) b\n        (empty? b) a\n        (&lt; a0 b0) (cons a0 (mrg (rest a) b))\n        (&gt; a0 b0) (cons b0 (mrg a (rest b)))\n        :else (cons a0 (mrg (rest a) (rest b)))\n        )\n      )\n    )\n  )\n(defn f2 [n] (* 2 n))\n(defn f3 [n] (* 3 n))\n(defn f5 [n] (* 5 n))\n(def h ( cons 1 (lazy-seq (mrg (mrg (map f2 h) (map f3 h)) (map f5 h) )) ))\n\n(defn hamming [n] (nth h n) )&quot; &quot;(defn f [a b c] (+ a b c))&quot; &quot;(f 1 2 3)&quot; &quot;(f 1 2 3 4)&quot; &quot;(apply f 1 2 3 4)&quot; &quot;(apply f (1 2 3 4))&quot; &quot;(defn af [&amp;a] (apply f a))&quot; &quot;(defn f2 [a b] (+ a b))&quot; &quot;(defn af2 [&amp;a] (apply f2 a))&quot; &quot;(f2 1 2 3 4)&quot; &quot;(+ 8)&quot; &quot;(+)&quot; &quot;(-)&quot; &quot;(- 1)&quot; &quot;(- 10)&quot; &quot;(- 10 2)&quot; &quot;(* 5)&quot; &quot;(*)&quot; &quot;(/ 2)&quot; &quot;(/)&quot; &quot;(- 10 2 2)&quot; &quot;(def a 3)&quot; &quot;(+ a (* a (+ (* 2 4) (+ a 5))) (+ (- 10 7) 6 1))&quot; &quot;(def a (+ (- 10 7) 6 1))&quot; &quot;(def b (- a 6))&quot; &quot;(def c (- a (* 2 b)))&quot; &quot;(+ a (* a (+ (* c b) (+ a 5))) (+ (- 10 7) c 1))&quot; &quot;( (def a 5) ( + a ( (def a 1) (+ a 1)) ))&quot; &quot;(def a 5)&quot; &quot;( (def a 5) ( + a ( (def b 1) (+ b 1)) ))&quot; &quot;( (def a 5) ( + a 1 ))&quot;], :remote []}}</component>
</project>